import scipy.signal

from qcodes.instrument_drivers.sqdlab.ADCProcessor import (
    Unpacker, DigitalDownconversion, Filter, Mean, Synchronizer, TvMode, 
    Instrument, ManualParameter, vals
)
import qcodes.instrument_drivers.sqdlab.dsp as dsp
import numpy as np
import pyopencl as cl

from qcodes.instrument_drivers.sqdlab.ADCProcessorGPU import *

# fake data generation
import numpy as np

def adc_rabi(shape, if_freq, signal, noise, markers=False, segment_offset=None):
    '''
    Generate adc input that simulates a noisy readout signal generated by
    a Rabi type experiment.

    shape: `tuple`
        (averages, segments, samples, channel)
    if_freq: `float`
     Carrier frequency of the input signal, 1=Nyquist frequency
    signal: `float`
        Signal amplitude
    noise: `float`
        Noise amplitude
    markers: `bool`
        If True, add 
    segment_offset: `int`, optional
        Index of the first segment. Defaults to a random number.
    '''
    averages, segments, samples, channels = shape
    # for each waveform, determine the state of the qubit (True or False)
    excited_exp = (1-np.cos(3*np.pi*(np.arange(segments))/segments))/2
    excited_shot = excited_exp[:,None] > np.random.rand(averages, segments, channels)
    # map the state to iq points
    ground = -(1+1j)/np.sqrt(2)
    excited = (1+1j)/np.sqrt(2)
    iq_shot = np.where(excited_shot, signal*excited, signal*ground)
    # modulate carrier with iq points
    carrier = np.exp(1j*np.pi*if_freq*np.arange(samples))
    waveforms = np.real(iq_shot[:,:,None,:]*carrier[:,None])
    # determine sequence start offset once
    segment_offset = np.random.randint(0, segments)
    # produce infinitely
    while True:
        # add noise
        if noise:
            waveforms += noise*(-1+2*np.random.rand(averages, segments, samples, channels))    
        # convert to short
        scale = (2**13) if markers else (2**15)
        data = np.clip(scale*waveforms, -scale, scale-1).astype(np.int16)
        if markers:
            # marker 1 is the sequence start marker
            # marker 2 is at a fixed position
            m1_start = min(10, samples)
            m1_stop = min(m1_start+10, samples)
            data &= 0x3fff
            data[:, 0, m1_start:m1_stop, 0] |= 0x8000
            data[:, :, m1_start:m1_stop, 0] |= 0x4000
        # convert to 2d and add sequence start offset
        data.shape = (data.shape[0]*data.shape[1],) + data.shape[2:]
        data = np.roll(data, segment_offset, 0)
        yield data


tvmode = TvModeGPU('tvmode')

if_freq = 0.2
tvmode.unpacker.markers.set(2)
tvmode.unpacker.out_dtype.set(np.float64)
tvmode.sync.method.set('all')
tvmode.sync.mask.set(0x02)
tvmode.ddc.intermediate_frequency.set(-if_freq)
tvmode.filter.mode.set('valid')
tvmode.filter.decimation.set(8)
#tvmode.filter.set_default_filter()
tvmode.filter.coefficients.set(scipy.signal.firwin(32, [0.125]))
tvmode.filter.description.set('firwin with 32 taps, 0.125 cutoff')
tvmode.fft.enabled.set(True)
shape = (128, 51, 8192//2, 2)

real_data = False
if real_data:
    averages, segments, samples, channels = shape
    iterations = 8
    digi.enable_channels((1<<channels)-1)
    for ch in range(channels):
        digi.set_channel_settings(0, mV_range=1000., input_path=1 , termination=0, 
                                  coupling=0, compensation=None)
    digi.set_ext0_OR_trigger_settings(spcm.SPC_TM_POS, termination=0, coupling=0, level0=500)
    digi.multipurpose_mode_0.set('digital_in')
    
    acquisitions = int(1.1*iterations*averages*segments)
    source = digi.multiple_trigger_fifo_acquisition(acquisitions, samples, averages*segments)
else:
    signal = 0.5
    noise = 0.5
    source = adc_rabi(shape, if_freq, signal, noise, markers=True)

print('acquisition time {:.0f}ms, {:.0f}MB data'.format(np.prod(shape)*2e-6, np.prod(shape)/2**19))

def repeat(source):
    block = source.__next__()
    while True:
        yield block

block_iter = tvmode(repeat(source))
#block_iter = tvmode(source)
