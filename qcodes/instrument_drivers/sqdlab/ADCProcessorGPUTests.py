from pytest import fixture, mark
import qcodes
import numpy as np
import scipy.signal
import pyopencl as cl

from .ADCProcessorGPU import (
    Unpacker, DigitalDownconversion, Filter, Synchronizer, TvModeGPU
)

@fixture(scope='module')
def ctx():
    for platform in cl.get_platforms():
        try:
            return cl.Context(
                dev_type=cl.device_type.GPU, 
                properties=[(cl.context_properties.PLATFORM, platform)]
            )
        except cl.cffi_cl.RuntimeError:
            pass
    raise RuntimeError('Unable to create an opencl context for a GPU device.')

@fixture(scope='module')
def cq(ctx):
    return cl.CommandQueue(ctx)

def adc(shape, if_freq, signal, noise, markers=False, segment_offset=None):
    '''
    Generate adc input that simulates a noisy readout signal generated by
    a Rabi type experiment.

    shape: `tuple`
        (averages, segments, samples, channel)
    if_freq: `float`
     Carrier frequency of the input signal, 1=Nyquist frequency
    signal: `float`
        Signal amplitude
    noise: `float`
        Noise amplitude
    markers: `bool`
        If True, add 
    segment_offset: `int`, optional
        Index of the first segment. Defaults to a random number.
    '''
    averages, segments, samples, channels = shape
    # for each waveform, determine the state of the qubit (True or False)
    excited_exp = (1-np.cos(3*np.pi*(np.arange(segments))/segments))/2
    excited_shot = excited_exp[:,None] > np.random.rand(averages, segments, channels)
    # map the state to iq points
    ground = -(1+1j)/np.sqrt(2)
    excited = (1+1j)/np.sqrt(2)
    iq_shot = np.where(excited_shot, signal*excited, signal*ground)
    # modulate carrier with iq points
    carrier = np.exp(1j*np.pi*if_freq*np.arange(samples))
    waveforms = np.real(iq_shot[:,:,None,:]*carrier[:,None])
    # determine sequence start offset once
    segment_offset = np.random.randint(0, segments)
    # produce infinitely
    while True:
        # add noise
        if noise:
            waveforms += noise*(-1+2*np.random.rand(averages, segments, samples, channels))    
        # convert to short
        scale = (2**13) if markers else (2**15)
        data = np.clip(scale*waveforms, -scale, scale-1).astype(np.int16)
        if markers:
            # marker 1 is the sequence start marker
            # marker 2 is at a fixed position
            m1_start = min(10, samples)
            m1_stop = min(m1_start+10, samples)
            data &= 0x3fff
            data[:, 0, m1_start:m1_stop, 0] |= 0x8000
            data[:, :, m1_start:m1_stop, 0] |= 0x4000
        # convert to 2d and add sequence start offset
        data.shape = (data.shape[0]*data.shape[1],) + data.shape[2:]
        data = np.roll(data, segment_offset, 0)
        yield data


@fixture(scope='module')
def instrument():
    return qcodes.Instrument('ins')

class TestUnpacker(object):
    @fixture
    def unpacker(self, instrument, markers):
        unpacker = Unpacker(instrument, 'unpacker')
        unpacker.markers.set(markers)
        return unpacker

    @fixture(params=[0,1,2])
    def markers(self, request):
        return request.param

    # sign extension
    @fixture
    def sign_extension(self, markers):
        return Unpacker.sign_extension_factory(16-markers)

    def test_sign_extension(self, sign_extension, markers):
        mask = (1<<(16-markers))-1
        data = np.random.randint(-(1<<(15-markers)), (1<<(15-markers))-1, (8,8), 
                                 dtype=np.int16)
        assert np.all(data == sign_extension(data & mask))

    # marker extraction
    @mark.parametrize('raw,digital_ref,markers', [
        (np.array([0, 0, 0, 0]), None, 0),
        (np.array([[0, 0, 0, 0]]), None, 0),
        (np.array([0x8000, 0x4000, 0x2000, 0xc000]), np.array([1,0,0,1]), 1),
        (np.array([0x8000, 0x4000, 0x2000, 0xc000]), np.array([2,1,0,3]), 2),
        (np.array([[0x8000, 0x4000, 0x2000, 0xc000]]*2), np.array([0b1001]*2), 1),
        (np.array([[0x8000, 0x4000, 0x2000, 0xc000]]*2), np.array([0b10010011]*2), 2),
    ])
    def test_pack_markers(self, unpacker, raw, digital_ref):
        raw = raw.astype(np.int16)
        digital = unpacker.pack_markers(raw)
        assert np.all(digital == digital_ref)

    # float conversion
    def test_call(self, unpacker):
        pass


class TestDigitalDownconversion(object):
    pass


class TestFilter(object):
    pass


class TestSynchronizer(object):
    pass


class TestTvMode(object):
    @fixture
    def tvmode(self, ctx, cq):
        return TvModeGPU('tvmode', ctx, cq)
    
    def test(self, tvmode):
        if_freq = 0.5
        tvmode.unpacker.markers.set(2)
        tvmode.sync.method.set('all')
        tvmode.sync.mask.set(0x02)
        tvmode.ddc.intermediate_frequency.set(-if_freq)
        tvmode.filter.mode.set('valid')
        tvmode.filter.decimation.set(8)
        #tvmode.filter.set_default_filter()
        tvmode.filter.coefficients.set(scipy.signal.firwin(64, [0.125]))
        tvmode.filter.description.set('firwin with 64 taps, 0.125 cutoff')

        shape = (128, 51, 8192//2, 2)
        signal = 0.5
        noise = 0.1
        source = adc(shape, if_freq, signal, noise, markers=True)
        def repeat(source):
            block = source.__next__()
            while True:
                yield block
        source = repeat(source)

        block_iter = tvmode(source)
        source.__next__()
        for rep in range(8):
            block_iter.__next__()
            print('block {} complete.'.format(rep))
