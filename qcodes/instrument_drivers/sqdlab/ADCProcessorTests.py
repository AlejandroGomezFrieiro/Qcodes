from pytest import fixture, mark
import qcodes
import numpy as np

from ADCProcessor import (
    Unpacker, DigitalDownconversion, Filter, Synchronizer, TvMode
)                      

def adc(shape, if_freq, signal, noise, markers=False, segment_offset=None):
    '''
    Generate adc input that simulates a noisy readout signal generated by
    a Rabi type experiment.

    shape: `tuple`
        (averages, segments, samples, channel)
    if_freq: `float`
     Carrier frequency of the input signal, 1=Nyquist frequency
    signal: `float`
        Signal amplitude
    noise: `float`
        Noise amplitude
    markers: `bool`
        If True, add 
    segment_offset: `int`, optional
        Index of the first segment. Defaults to a random number.
    '''
    averages, segments, samples, channels = shape
    # for each waveform, determine the state of the qubit (True or False)
    excited_exp = (1-np.cos(3*np.pi*(np.arange(segments))/segments))/2
    excited_shot = excited_exp[:,None] > np.random.rand(averages, segments, channels)
    # map the state to iq points
    ground = -(1+1j)/np.sqrt(2)
    excited = (1+1j)/np.sqrt(2)
    iq_shot = np.where(excited_shot, signal*excited, signal*ground)
    # modulate carrier with iq points
    carrier = np.exp(1j*np.pi*if_freq*np.arange(samples))
    waveforms = np.real(iq_shot[:,:,None,:]*carrier[:,None])
    # determine sequence start offset once
    segment_offset = np.random.randint(0, segments)
    # produce infinitely
    while True:
        # add noise
        if noise:
            waveforms += noise*(-1+2*np.random.rand(averages, segments, samples, channels))    
        # convert to short
        scale = (2**13) if markers else (2**15)
        data = np.clip(scale*waveforms, -scale, scale-1).astype(np.int16)
        if markers:
            # marker 1 is the sequence start marker
            # marker 2 is at a fixed position
            m1_start = min(10, samples)
            m1_stop = min(m1_start+10, samples)
            data &= 0x3fff
            data[:, 0, m1_start:m1_stop, 0] |= 0x8000
            data[:, :, m1_start:m1_stop, 0] |= 0x4000
        # convert to 2d and add sequence start offset
        data.shape = (data.shape[0]*data.shape[1],) + data.shape[2:]
        data = np.roll(data, segment_offset, 0)
        yield data


@fixture(scope='module')
def instrument():
    return qcodes.Instrument('ins')

class TestUnpacker(object):
    @fixture
    def unpacker(self, instrument, markers):
        unpacker = Unpacker(instrument, 'unpacker')
        unpacker.markers.set(markers)
        return unpacker

    @fixture(params=[0,1,2])
    def markers(self, request):
        return request.param

    # sign extension
    @fixture
    def sign_extension(self, markers):
        return Unpacker.sign_extension_factory(16-markers)

    def test_sign_extension(self, sign_extension, markers):
        mask = (1<<(16-markers))-1
        data = np.random.randint(-(1<<(15-markers)), (1<<(15-markers))-1, (8,8), 
                                 dtype=np.int16)
        assert np.all(data == sign_extension(data & mask))

    # marker extraction
    @mark.parametrize('raw,digital_ref,markers', [
        (np.array([0, 0, 0, 0]), None, 0),
        (np.array([[0, 0, 0, 0]]), None, 0),
        (np.array([0x8000, 0x4000, 0x2000, 0xc000]), np.array([1,0,0,1]), 1),
        (np.array([0x8000, 0x4000, 0x2000, 0xc000]), np.array([2,1,0,3]), 2),
        (np.array([[0x8000, 0x4000, 0x2000, 0xc000]]*2), np.array([0b1001]*2), 1),
        (np.array([[0x8000, 0x4000, 0x2000, 0xc000]]*2), np.array([0b10010011]*2), 2),
    ])
    def test_pack_markers(self, unpacker, raw, digital_ref):
        raw = raw.astype(np.int16)
        digital = unpacker.pack_markers(raw)
        assert np.all(digital == digital_ref)

    # float conversion
    def test_call(self, unpacker):
        pass


class TestDigitalDownconversion(object):
    pass


class TestFilter(object):
    pass


class TestSynchronizer(object):
    pass


class TestTvMode(object):
    @fixture
    def tvmode(self):
        return TvMode('tvmode')
    
    def test(self, tvmode):
        tvmode.unpacker.markers.set(2)
        tvmode.sync.method.set('two')
        tvmode.ddc.intermediate_frequency.set(0.5)

        shape = (64, 64, 64, 1)
        if_freq = 0.5
        signal = 0.5
        noise = 0.1
        source = adc(shape, if_freq, signal, noise, markers=True)

        block_iter = tvmode(source)
        block_iter.__next__()
        pass